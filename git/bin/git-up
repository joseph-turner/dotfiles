#!/bin/zsh

autoload colors; colors

local check=0
local stashed

while getopts "C" opt; do
  case $opt in
    C)
      check=false
      ;;
    \?)
      echo "Invalid option: -$OPTARG"
      return 1
      ;;
    :)
      echo "Option -$OPTARG requires an argument"
      return 1
      ;;
  esac
done
shift $((OPTIND -1))

local branch=$(git for-each-ref --format='%(upstream:short)' "$(git symbolic-ref -q HEAD)")
[[ -z $branch ]] && echo "Current branch (`git rev-parse --abbrev-ref HEAD`) has no upstream" && exit 1
local pkg=false
local nvm=false

echo "$fg[blue]Merging from $branch$reset_color\n"

while ! git fetch --prune origin &>/dev/null; do
  echo "\n$fg[red]Error fetching latest $branch!$reset_color"
  if ! read -qs "?Press \"Y\" to try again, or any other key to abort fetch."$'\n'; then
    exit 1
  fi
done

# check for yarn.lock and set dep
# check for .nvmrc and set nvm
if [[ $check = 0 ]]; then
  local gdiff=`git diff --name-only "$branch"`
  [[ $(grep "yarn.lock" <<< $gdiff) ]] && dep=true
  [[ $(grep ".nvmrc" <<< $gdiff) ]] && nvm=true
fi

if git conditional-stash; then
  stashed=1
fi

git merge "$branch" || git conflicts

if [[ $stashed == '1' ]]; then
  git stash pop
fi

function update_dep() {
  echo
  echo "Changes detected in yarn.lock"
  echo
  bounce
}

function update_node() {
  echo
  echo "Change detected in .nvmrc"
  echo
  export NVM_DIR=~/.nvm
  [[ -s $NVM_DIR/nvm.sh ]] && . "$NVM_DIR/nvm.sh"
  nvm use
}

[[ $dep = true ]] && update_dep
[[ $nvm = true ]] && update_node
